import json
import os
from typing import Optional
from groq import Groq
from pip._internal.resolution.resolvelib import provider

from src.models import Command, Scene, ActionPlan, RobotAction, Position

class LLMClient:
    """
    Client for interacting with LLMs to generate robot action plans.
    Currently, uses Groq API
    """

    def __init__(
            self,
            provider: str = 'groq',
            api_key: Optional[str] = None,
            model: str = 'llama-3.1-8b-instant'
    ):
        """
        Initialize the LLM client.
        :param provider: LLM provider
        :param api_key: API key for the provider. If None, it reads from environment
        :param model: Model name to use. Groq options:
                        - 'llama-3.1-70b-versatile' (recommended, best quality)
                        - "llama-3.1-8b-instant" (faster, good quality)
                        - "mixtral-8x7b-32768" (alternative)
        Environment variables:
            GROQ_API_KEY: API key for Groq (if api_key not provided)
        """
        self.provider = provider
        self.model = model

        if provider == 'groq':
            # Get api key from parameter or environment
            api_key = api_key or os.getenv('GROQ_API_KEY')
            if not api_key:
                raise ValueError(
                    "Groq API key required. Provide via api_key parameter or "
                    "set GROQ_API_KEY environment variable."
                )
            self.client = Groq(api_key=api_key)
        else:
            raise NotImplementedError(f'Provider "{provider}" not implemented')

    def generate_plan(self, command: Command, scene: Scene) -> ActionPlan:
        """
        Generate a robot action plan based on command and scene.
        :param command: User command
        :param scene: Scene description with detected objects
        :return: ActionPlan with sequence of robot actions
        """

        if self.provider == 'groq':
            return self._generate_with_groq(command, scene)
        else:
            raise NotImplementedError(f'Provider "{self.provider}" not implemented')

    def _generate_with_groq(self, command: Command, scene: Scene) -> ActionPlan:
        """
        Generate plan using Groq API.
        :param command: User command
        :param scene: Scene description
        :return: ActionPlan generated by LLM
        """

        # Create system prompt
        system_prompt = self._create_system_prompt()
        # Create user prompt with command and scene
        user_prompt = self._create_user_prompt(command, scene)

        # Call Groq API
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,  # Lower = more consistent/predictable
            max_tokens=1000,
            response_format={"type": "json_object"}  # Force JSON output
        )

        # parse response
        response_text = response.choices[0].message.content

        # convert json to ActionPlan
        return self._parse_response(response_text)

    def _create_system_prompt(self):
        """
        Create system prompt that defines the LLM's role
        :return: System prompt string
        """
        return """You are a robot action planner for a humanoid robot. You job is to:
        
1. Analyze the user's command and the scene description
2. Generate a sequence of robot actions to accomplish the task
3. Output ONLY valid JSON in this exact format:

{
  "actions": [
    {
      "type": "move_to" | "grasp" | "release" | "look_at",
      "target": "object_name",
      "end_effector": "right_hand" | "left_hand",
      "position": {"x": 0.0, "y": 0.0, "z": 0.0},
      "parameters": {}
    }
  ],
  "confidence": 0.0-1.0,
  "reasoning": "brief explanation"
}

ACTION TYPES:
- move_to: Move end effector to object position
- grasp: Close gripper to grab object
- release: Open gripper to release object  
- look_at: Orient cameras/head toward object

RULES:
- Use object positions from the scene
- For "pick up", use: move_to → grasp
- For "put down", use: move_to → release
- Always specify which hand to use
- Keep reasoning brief (one sentence)
- Output ONLY JSON, no other text 
        """

    def _create_user_prompt(self, command: Command, scene: Scene) -> str:
        """
        Create user prompt with command and scene info
        :param command: User's command
        :param scene: Scene description
        :return: User prompt string
        """

        # Convert scene into simple dict for LLM
        scene_dict = {
            'description': scene.description,
            'objects': [
                {
                    'name': obj.name,
                    'type': obj.object_type,
                    'position': {
                        'x': obj.position.x,
                        'y': obj.position.y,
                        'z': obj.position.z
                    }
                }
                for obj in scene.objects
            ]
        }
        prompt = f""" COMMAND: {command.text}
        SCENE:
{json.dumps(scene_dict, indent=2)}

Generate the action plan as JSON:
"""
        return prompt

    def _parse_response(self, response_text: str) -> ActionPlan:
        """
        Parse LLM json respone into ActionPlan object
        :param response_text: json string from LLM
        :return: ActionPlan object
        :raises ValueError: if response is invalid json or missing fields
        """
        try:
            data = json.loads(response_text)
        except json.decoder.JSONDecodeError as e:
            raise ValueError(f'LLM return invalid json: {e}')

        actions = []
        for action_data in data.get('actions', []):
            # handle position
            position = None
            if action_data.get('position'):
                pos_data = action_data['position']
                position = Position(
                    x=pos_data['x'],
                    y=pos_data['y'],
                    z=pos_data['z']
                )

            action = RobotAction(
                type=action_data['type'],
                target=action_data['target'],
                end_effector=action_data.get('end_effector', 'right_hand'),
                position=position,
                parameters=action_data.get('parameters', {})
            )
            actions.append(action)

        plan = ActionPlan(
            actions=actions,
            confidence=data.get('confidence', 0.8),
            reasoning=data.get('reasoning')
        )

        return plan

# Convenience function
def generate_plan(command: Command, scene: Scene, api_key: Optional[str] = None) -> ActionPlan:
    """
    Convenience function to generate a plan without creating a client
    :param command: Users command
    :param scene: Scene description
    :param api_key: Groq API key (or use GROQ_API_KEY environment variable)
    :return: ActionPlan with robot actions
    """
    client = LLMClient(api_key=api_key)
    return client.generate_plan(command, scene)













